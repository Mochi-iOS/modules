"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginBundle = exports.pluginTypeCheck = exports.buildOptions = exports.toKebabCase = exports.retrieveMochiJSVersion = void 0;
const path = __importStar(require("path"));
const vm_1 = __importDefault(require("vm"));
const consola_1 = __importDefault(require("consola"));
const promises_1 = require("fs/promises");
const ejs_1 = __importDefault(require("ejs"));
const typescript_1 = __importDefault(require("typescript"));
const esbuild_1 = __importDefault(require("esbuild"));
const MOCHI_JS_NAME = '@mochiapp/js';
const getModulesDirectories = async (basedir, log = true) => {
    consola_1.default.log('');
    consola_1.default.info(`Verifying ${basedir}`);
    const directories = await (0, promises_1.readdir)(path.join(basedir, 'src'));
    const allModules = await Promise.all(directories.map((item) => {
        const itemPath = path.join(basedir, 'src', item);
        const itemIndexPath = path.join(itemPath, 'index.ts');
        return (0, promises_1.stat)(itemIndexPath)
            .then((s) => {
            if (s.isFile()) {
                if (log)
                    consola_1.default.log(`   \x1b[32m\u21B3\x1b[0m ${itemIndexPath} - module found!`);
                return {
                    name: item,
                    path: itemPath,
                };
            }
            else {
                throw new Error(''); // stub
            }
        })
            .catch(() => {
            if (log)
                consola_1.default.log(`   \x1b[33m\u26A0\x1b[0m ${itemPath} - does not contain an index.ts file, skipping..`);
            return undefined;
        });
    })).then((l) => l.filter((i) => !!i));
    consola_1.default.log('');
    consola_1.default.info(`Found ${allModules.length} module${allModules.length == 1 ? '' : 's'}.`);
    return allModules;
};
const retrieveMochiJSVersion = async (src) => {
    consola_1.default.log('');
    const version = await (0, promises_1.readFile)(path.resolve(src, 'node_modules', MOCHI_JS_NAME, 'package.json'), {
        encoding: 'utf-8',
    })
        .catch((e) => {
        throw Error(`Failed to retrieve ${MOCHI_JS_NAME} version - ${e}`);
    })
        .then((value) => JSON.parse(value))
        .then((json) => {
        if (json === null || json === void 0 ? void 0 : json.version)
            return json.version;
        throw Error(`could not parse ${MOCHI_JS_NAME} version in node_modules/${MOCHI_JS_NAME}/package.json`);
    });
    consola_1.default.info(`found ${MOCHI_JS_NAME} version: ${version}`);
    return version;
};
exports.retrieveMochiJSVersion = retrieveMochiJSVersion;
function toKebabCase(value) {
    return value
        .toLowerCase()
        .replace(/([a-z])([A-Z])/g, '$1-$2')
        .replace(/[\s_]+/g, '-');
}
exports.toKebabCase = toKebabCase;
// TODO: Add JS support
// const isTypeScriptProject = async (dir: string) => {
//   return (await stat(path.resolve(dir, 'tsconfig.json'))).isFile();
// }
const REPOSITORY_GEN_NAME = '__repository';
const buildOptions = async (basedir, outOptions, typecheck = true) => {
    var _a, _b, _c, _d;
    const mochiJSVesion = await (0, exports.retrieveMochiJSVersion)(basedir);
    const modulesDirs = await getModulesDirectories(basedir);
    const entryPoints = modulesDirs.map((d) => {
        return {
            in: path.resolve(d.path, 'index.ts'),
            out: d.name,
        };
    });
    const plugins = [];
    // FIXME: right now typecheck is ignored for fast development.
    // Maybe cached last modified file to avoid slowdowns?
    if (typecheck && !((_a = outOptions === null || outOptions === void 0 ? void 0 : outOptions.serve) !== null && _a !== void 0 ? _a : false))
        plugins.push((0, exports.pluginTypeCheck)(basedir));
    if (outOptions)
        plugins.push((0, exports.pluginBundle)(outOptions, mochiJSVesion));
    return {
        entryPoints: entryPoints.concat([{ in: path.resolve(basedir, 'index.ts'), out: REPOSITORY_GEN_NAME }]),
        allowOverwrite: true,
        bundle: (_b = outOptions === null || outOptions === void 0 ? void 0 : outOptions.bundle) !== null && _b !== void 0 ? _b : true,
        globalName: 'source',
        outdir: path.resolve((_c = outOptions === null || outOptions === void 0 ? void 0 : outOptions.outdir) !== null && _c !== void 0 ? _c : path.resolve(basedir, 'dist'), 'modules'),
        write: false,
        plugins: plugins,
        minify: !((_d = outOptions === null || outOptions === void 0 ? void 0 : outOptions.serve) !== null && _d !== void 0 ? _d : false),
        tsconfig: path.resolve(basedir, 'tsconfig.json'),
        absWorkingDir: basedir,
    };
};
exports.buildOptions = buildOptions;
const pluginTypeCheck = (src) => ({
    name: 'type-check',
    setup(build) {
        build.onStart(async () => {
            consola_1.default.log('');
            consola_1.default.start('Checking project...');
            const tsConfigFilePath = build.initialOptions.tsconfig;
            const configOptions = await (0, promises_1.readFile)(tsConfigFilePath, { encoding: 'utf8' })
                .then((tsConfigString) => typescript_1.default.parseConfigFileTextToJson(tsConfigFilePath, tsConfigString))
                .then((tsConfigJSON) => typescript_1.default.parseJsonConfigFileContent(tsConfigJSON.config, typescript_1.default.sys, src))
                .then((object) => {
                if (object.options)
                    return object.options;
                throw new Error(`failed to parse ${tsConfigFilePath}.`);
            })
                .catch((e) => {
                consola_1.default.warn(`an error occurred parsing tsconfig.json, using default tsconfig instead. error log: ${e}`);
                return {};
            })
                .then((o) => {
                // We do not want to emit any files from ts to js.
                o.noEmit = true;
                return o;
            });
            const entryPoints = build.initialOptions.entryPoints;
            const program = typescript_1.default.createProgram(entryPoints.map((i) => i.in), configOptions);
            const emitResult = program.emit();
            const allDiagnostics = typescript_1.default.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
            if (allDiagnostics.length > 0)
                consola_1.default.log('');
            await logDiagnostics(src, allDiagnostics);
            if (allDiagnostics.findIndex((value) => value.category == typescript_1.default.DiagnosticCategory.Error) !== -1) {
                throw new Error('This project has errors. Please resolve them before bundling.');
            }
            consola_1.default.success('Successfully checked project and reported 0 build erros!');
        });
    },
});
exports.pluginTypeCheck = pluginTypeCheck;
const pluginBundle = (options, mochiJSVersion) => ({
    name: 'bundle',
    setup(build) {
        build.onEnd(async (result) => {
            var _a;
            if (result.errors.length > 0) {
                consola_1.default.fail('Failed to bundle due to previous errors.');
                return;
            }
            consola_1.default.log('');
            consola_1.default.start('Bundling repository...');
            const releases = [];
            let repositoryMetadata;
            const DEST_MODULES_PATH = path.resolve(options.outdir, 'modules');
            const DEST_MANIFEST_PATH = path.resolve(options.outdir, 'Manifest.json');
            for (const output of result.outputFiles) {
                const fileNameWExt = path.basename(output.path);
                const fileExt = path.extname(fileNameWExt);
                const fileName = path.basename(fileNameWExt, fileExt);
                if (fileExt != '.js')
                    continue;
                if (REPOSITORY_GEN_NAME === fileName) {
                    const metadata = vm_1.default.runInNewContext(`${output.text}; source.default`);
                    if (metadata) {
                        repositoryMetadata = metadata;
                    }
                    else {
                        throw new Error(`failed to retrieve metadata content for ${fileNameWExt}. Make sure this repository's index.ts exports \`RepoMetadata\` by default.`);
                    }
                }
                else {
                    const metadata = vm_1.default.runInNewContext(`${output.text}; new source.default().metadata`);
                    if (metadata) {
                        metadata.id = (_a = metadata.id) !== null && _a !== void 0 ? _a : `${toKebabCase(metadata.name)}`;
                        metadata.file = `/modules/${fileNameWExt}`;
                        metadata.meta = []; // TODO: gather if it has video, image, or source
                        metadata.mochiJSVersion = mochiJSVersion;
                        releases.push(metadata);
                    }
                    else {
                        throw new Error(`failed to retrieve metadata content from ${fileNameWExt}. Make sure the module class is exported by default and extends \`SourceModule\` or \`TrackerModule\`.`);
                    }
                }
            }
            if (!repositoryMetadata)
                throw new Error(`failed to retrieve metadata content from repository's src/index.ts`);
            const manifest = {
                repository: repositoryMetadata,
                modules: releases,
            };
            // delete old modules and manifest in dest if present
            await (0, promises_1.rm)(DEST_MODULES_PATH, { recursive: true, force: true });
            await (0, promises_1.rm)(DEST_MANIFEST_PATH, { force: true });
            await (0, promises_1.mkdir)(DEST_MODULES_PATH, { recursive: true });
            await (0, promises_1.writeFile)(DEST_MANIFEST_PATH, JSON.stringify(manifest, undefined, 2));
            await Promise.all(result.outputFiles.map((o) => {
                if (!o.path.includes(REPOSITORY_GEN_NAME)) {
                    return (0, promises_1.writeFile)(o.path, o.contents);
                }
                return undefined;
            }));
            if (options.site) {
                consola_1.default.log('');
                consola_1.default.start(`Generating site for repository...`);
                const template = await (0, promises_1.readFile)(path.resolve(__dirname, 'templates/site/index.ejs'), {
                    encoding: 'utf-8',
                });
                const output = await ejs_1.default.render(template, manifest, { async: true });
                await (0, promises_1.writeFile)(path.join(options.outdir, 'index.html'), output);
                consola_1.default.success(`Successfully generated site!\n`);
            }
            consola_1.default.success('Successfully finished bundling repository!');
        });
    },
});
exports.pluginBundle = pluginBundle;
function transformDiagnostic(basedir, diagnostic) {
    const message = typescript_1.default.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
    const { code, file, length, start } = diagnostic;
    if (!file)
        return {
            id: `TS${code}`,
            text: message,
        };
    if (!start || !length)
        return {
            id: `TS${code}`,
            text: message,
        };
    const { line, character } = file.getLineAndCharacterOfPosition(start);
    const lastLineInFile = file.getLineAndCharacterOfPosition(file.text.length).line;
    const lineStart = file.getPositionOfLineAndCharacter(line, 0);
    const lineEnd = line < lastLineInFile ? file.getPositionOfLineAndCharacter(line + 1, 0) : file.text.length;
    const lineText = file.text.slice(lineStart, lineEnd).trimEnd();
    const safeLength = character + length > lineEnd - lineStart ? lineEnd - lineStart - character : length;
    return {
        id: `TS${code}`,
        text: message,
        location: {
            file: path.relative(basedir, file.fileName),
            line: line + 1,
            column: character,
            length: safeLength,
            lineText: lineText,
        },
    };
}
async function logDiagnostics(basedir, diagnostics) {
    const errors = diagnostics
        .filter((d) => d.category == typescript_1.default.DiagnosticCategory.Error)
        .map((d) => transformDiagnostic(basedir, d));
    const warnings = diagnostics
        .filter((d) => d.category != typescript_1.default.DiagnosticCategory.Error)
        .map((d) => transformDiagnostic(basedir, d));
    if (errors.length > 0) {
        await esbuild_1.default
            .formatMessages(errors, {
            color: true,
            kind: 'error',
        })
            .then((o) => consola_1.default.log(o.join('\n')));
    }
    if (warnings.length > 0) {
        await esbuild_1.default
            .formatMessages(warnings, {
            color: true,
            kind: 'warning',
        })
            .then((o) => consola_1.default.log(o.join('\n')));
    }
}
