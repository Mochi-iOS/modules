"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleInitModule = exports.handleInitRepo = void 0;
const consola_1 = __importDefault(require("consola"));
const ejs_1 = __importDefault(require("ejs"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const path_1 = __importDefault(require("path"));
const utils_1 = require("../utils");
async function handleInitRepo(dir, name, author) {
    if (name.trim().length == 0) {
        throw new Error('Repo name cannot be empty.');
    }
    if (author.trim().length == 0) {
        throw new Error('Author name cannot be empty.');
    }
    const repo = {
        name: name,
        author: author,
    };
    const templateRepoPath = path_1.default.resolve(__dirname, '../templates/repo');
    const allFiles = await (0, promises_1.readdir)(templateRepoPath, { recursive: true });
    consola_1.default.start('Initializing new repo..');
    dir = path_1.default.resolve(path_1.default.join(process.cwd(), (0, utils_1.toKebabCase)(name)), dir);
    await (0, promises_1.mkdir)(path_1.default.join(dir, 'src'), { recursive: true });
    for (const item of allFiles) {
        const templateItemPath = path_1.default.join(templateRepoPath, item);
        const stats = await (0, promises_1.stat)(templateItemPath);
        if (stats.isDirectory()) {
            await (0, promises_1.mkdir)(path_1.default.join(dir, item), { recursive: true });
        }
        else {
            const destinationPath = path_1.default.join(dir, item);
            if (item.includes('gitignore')) {
                await (0, promises_1.cp)(templateItemPath, path_1.default.join(dir, `.${item}`));
            }
            else if (item.includes('.ejs')) {
                const template = await (0, promises_1.readFile)(templateItemPath, {
                    encoding: 'utf-8',
                });
                const output = await ejs_1.default.render(template, repo, { async: true });
                await (0, promises_1.writeFile)(destinationPath.replace('.ejs', ''), output);
            }
            else {
                await (0, promises_1.cp)(templateItemPath, path_1.default.join(dir, item), { recursive: true });
            }
        }
    }
    consola_1.default.success(`Successfully created repo in ${dir}`);
}
exports.handleInitRepo = handleInitRepo;
async function handleInitModule(dir, name) {
    consola_1.default.start('Initializing new module...');
    if (name.trim().length == 0) {
        throw new Error('Module name cannot be empty.');
    }
    dir = path_1.default.resolve(process.cwd(), dir);
    await (0, utils_1.retrieveMochiJSVersion)(dir);
    const srcDir = path_1.default.join(dir, 'src');
    const casePathName = toPascalCase(name);
    const module = {
        className: casePathName,
        displayName: name,
    };
    // Check if there's no directory with the same name
    const moduleDir = path_1.default.join(srcDir, casePathName.toLowerCase());
    if ((0, fs_1.existsSync)(moduleDir))
        throw new Error(`cannot create module with name ${name}: directory exists.`);
    const template = await (0, promises_1.readFile)(path_1.default.resolve(__dirname, '../templates/module/index.ejs'), {
        encoding: 'utf-8',
    });
    const output = await ejs_1.default.render(template, module, { async: true });
    await (0, promises_1.mkdir)(moduleDir, { recursive: true });
    await (0, promises_1.writeFile)(path_1.default.join(moduleDir, 'index.ts'), output);
    await (0, promises_1.mkdir)(path_1.default.join(moduleDir, 'res'));
    consola_1.default.log('');
    consola_1.default.success(`Successfully created module in ${moduleDir}`);
}
exports.handleInitModule = handleInitModule;
const toPascalCase = (str) => {
    var _a, _b;
    return (_b = (_a = str
        .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g)) === null || _a === void 0 ? void 0 : _a.map((x) => x.charAt(0).toUpperCase() + x.slice(1).toLowerCase()).join('')) !== null && _b !== void 0 ? _b : '';
};
